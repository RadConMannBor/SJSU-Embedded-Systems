/*
 * LabGPIOInterrupts.cpp
 *
 *  Created on: Feb 22, 2018
 *      Author: cborm
 */

#include <LabGPIOInterrupts.h>

LabGPIOInterrupts::LabGPIOInterrupts()
{


}

LabGPIOInterrupts::~LabGPIOInterrupts()
{

}



void LabGPIOInterrupts::extIRQhandler(void){
       if( LPC_GPIOINT->IO0IntStatR &  (1<<1)||LPC_GPIOINT->IO0IntStatF & (1<<1)){
           LPC_GPIOINT->IO0IntClr = (1<<1);
           //P0.1
           //xsemaphoreGive(xSemaphore);
       }
       if( LPC_GPIOINT->IO0IntStatR &(1<<1)||LPC_GPIOINT->IO0IntStatF & (1<<1)){
          LPC_GPIOINT->IO0IntClr = (1<<1);
          //P0.1
          //xsemaphoreGive(xSemaphore);
      }

   }

  /* LabGPIOInterrupts* LabGPIOInterrupts::pointerSingleton(){
       return NULL;
   }

   LabGPIOInterrupts* LabGPIOInterrupts::Singleton(){
       if(pointerSingleton == NULL)
       {
           pointerSingleton = new LabGPIOInterrupts(); //new pointer if null
       }
       return (pointerSingleton);
   }
*/

   /**
    * This should configure NVIC to notice EINT3 IRQs; use NVIC_EnableIRQ()
    *//*
   void LabGPIOInterrupts::init()
   {
       isr_register(EINT3_IRQn, );
       NVIC_EnableIRQ(EINT3_IRQn);
   }*/


   /**
    * This handler should place a function pointer within the lookup table for the handle_interrupt() to find.
    *
    * @param[in] port         specify the GPIO port
    * @param[in] pin          specify the GPIO pin to assign an ISR to
    * @param[in] pin_isr      function to run when the interrupt event occurs
    * @param[in] condition    condition for the interrupt to occur on. RISING, FALLING or BOTH edges.
    * @return should return true if valid ports, pins, isrs were supplied and pin isr insertion was sucessful
    */

   bool LabGPIOInterrupts::attachInterruptHandler (uint8_t port, uint32_t pin, void (*pin_isr)(void),uint8_t condition){
       bool test;
       PortNum = port;
       PinNum = pin;
       if(PortNum == 0){
           test = false;
           if (condition == 0){
               LPC_GPIOINT->IO0IntEnF |= (1<<PinNum);
           }
           else if (condition == 1){
               LPC_GPIOINT->IO0IntEnR |= (1<<PinNum);
           }
           else{
               LPC_GPIOINT->IO0IntEnR |= (1<<PinNum);
               LPC_GPIOINT->IO0IntEnF |= (1<<PinNum);
           }

       }
       /*
       else if (PortNum == 1){
           test = true; //switch
           if(condition){
               if(condition == 0){
                  LPC_GPIOINT->IO0IntEnF |= (1<<PinNum);
               }
               else if (condition == 1){
                   LPC_GPIOINT->IO0IntEnR |= (1<<PinNum);
               }
               else{
                   LPC_GPIOINT->IO0IntEnR |= (1<<PinNum);
                   LPC_GPIOINT->IO0IntEnF |= (1<<PinNum);
               }
           }
       }*/
       return (test);

   }
   /**
    * This function is invoked by the CPU (through c_eint3_handler) asynchronously when a Port/Pin
    * interrupt occurs. This function is where you will check the Port status, such as IO0IntStatF,
    * and then invoke the user's registered callback and find the entry in your lookup table.
    *
    * VERY IMPORTANT!
    *  - Be sure to clear the interrupt flag that caused this interrupt, or this function will be called
    *    repetitively and lock your system.
    *  - NOTE that your code needs to be able to handle two GPIO interrupts occurring at the same time.
    */
   void handle_interrupt(void);
