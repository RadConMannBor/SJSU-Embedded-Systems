/*
 * LabUART.cpp
 *
 *  Created on: Mar 9, 2018
 *      Author: cborm
 */

#include <LabUART.h>

#include "UARTDriver.h"

bool LabUART::getBool(){
    return this->IsDataAvailable;
}

void LabUART::my_uart2_intr(){
    uint16_t clearInterrupt;
    const uint16_t dataReady = (2 << 1);
    char data;

    clearInterrupt = (LPC_UART2->IIR & 0xE);    //Clear

    //Switch between UART
    switch(n){
        case 2:

            if(clearInterrupt && dataReady){
                while(0 != (LPC_UART2->LSR & (1 << 0))){
                data = LPC_UART2->RBR;  //Receive Data from RBR
                xQueueSendFromISR(RXqueue, &data, NULL);    //Send to queue
            }
            IsDataAvailable = true;
            }
            break;

        case 3:
            while(0 != (LPC_UART3->LSR & (1 << 0))){
                data = LPC_UART3->RBR;  //Receive data from RBR
                xQueueSendFromISR(RXqueue, &data, NULL);    //Send to queue
            }
            IsDataAvailable = true;
            break;
    }

}

void LabUART::init(UART sel){
   n = sel;
   //Switch between uart
    switch(n){
        case 2: {
            LPC_SC->PCONP |= (1 << 24);     //enable power  UART2
            LPC_SC->PCLKSEL1 |= (1 << 16);  //select PCLK = CCLK

            LPC_UART2->FCR = (1 << 0) | (1 << 6);   // Enable & Reset FIFOs
            LPC_UART2->FCR |= (1 << 1) | (1 << 2);

            uint16_t baud = ( sys_get_cpu_clock() / (16 * 9600)) + 0.5; //Calculate baud rate

            LPC_UART2->LCR = (1 << 7);          // Enable DLAB

            LPC_UART2->DLM = (baud >> 8);   //Set baud rate
            LPC_UART2->DLL = (baud >> 0);   //Set baud rate


            LPC_UART2->LCR = 3;         //Disable DLAB


            LPC_UART2->IER = (1 << 0) | (1 << 1) | (1 << 2); // Enable Interrupts for receiving

            LPC_PINCON->PINSEL4 |= (0xA << 16); //Pinsel TXD2 and RXD2

            break;
        }
        case 3:
        {
            LPC_SC->PCONP |= (1 << 25);     //enable power UART2
            LPC_SC->PCLKSEL1 |= (1 << 18);  //select PCLK = CCLK

            LPC_UART3->FCR = (1 << 0) | (1 << 6);   // Enable & Reset FIFOs
            LPC_UART3->FCR |= (1 << 1) | (1 << 2);

            uint16_t baud = ( sys_get_cpu_clock() / (16 * 9600)) + 0.5; //Calculate baud rate


            LPC_UART3->LCR = (1 << 7);          // Enable DLAB

            LPC_UART3->DLM = (baud >> 8);       //Set baud rate
            LPC_UART3->DLL = (baud >> 0);       //Set baud rate

            LPC_UART3->LCR = 3;     //Disable DLAB


            LPC_UART3->IER = (1 << 0) | (1 << 1) | (1 << 2); //Interrupts receive

            LPC_PINCON->PINSEL9 |= (0xF << 24); //PINSEL

            break;

        }

    }
    //create queues
    TXqueue = xQueueCreate(8, sizeof(char));
    RXqueue = xQueueCreate(8, sizeof(char));

}

void LabUART::sendChar(char out){
    LPC_UART2->THR = out;   //Write to THR
}

char LabUART::getChar(){
    char data;
    xQueueReceive(RXqueue, &data, 10);  //Fetch from queue
    IsDataAvailable = false;
    return data;
}


/*
LabUART::LabUART()
{
    // TODO Auto-generated constructor stub

}

LabUART::~LabUART()
{
    // TODO Auto-generated destructor stub
}

void LabUART::init(Peripheral peripheral)
{
    // TODO: Queue your data and clear UART Rx interrupt
    if(peripheral = 2){
       LPC_SC->PCONP |= (1<<24);
       //Turn on Clock
       LPC_SC->PCLKSEL1 &=~(3<<16);
       LPC_SC->PCLKSEL1 |= (1<<16);
       //set DLAB = 1
       LPC_UART2->LCR |=(1<<7);
       //set frame size to 8
       LPC_UART2->LCR|=(3<<0);
       //set baud rate 57600
       uint8_t dll = sys_get_cpu_clock() / (16 * 38400); //get dll
       LPC_UART2->DLL = dll;

       //LPC_UART2->DLL =(0x625<<0)&0xFF;//or 104 if it changes
       //LPC_UART2->DLM =(0x625<<8)&0xFF;

       LPC_PINCON->PINSEL4 &= ~(0xF << 16); // Clear values
       LPC_PINCON->PINSEL4 |=  (0xA << 16);
       //Select tx2
       //LPC_PINCON->PINSEL0 |= (1 << 20);
       //Select rx2
       //LPC_PINCON->PINSEL0 |= (1 << 22);
       //SET dlab to 0
       LPC_UART2->LCR |=(0<<7);
       //Turn RX2 interrupts on
       LPC_UART2->IER |=(1<<0);

       LPC_UART2->IER |=(1<<2);//set rx line status to 1 bit 2

       LPC_UART2->FCR |=(1<<0);
       LPC_UART2->FCR |=(1<<1);
       LPC_UART2->FCR |=(1<<2);
       LPC_UART2->FCR |=(1<<3);
       LPC_UART2->FCR |=(0<<6);
       LPC_UART2->TER |=(1<<7); //transmit enable

       isr_register(UART2_IRQn, my_uart2_rx_intr);
       NVIC_EnableIRQ(UART2_IRQn);
    }
    else if(peripheral = 3)
    {
            LPC_SC->PCONP |= (1<<24);
           //Turn on Clock
           LPC_SC->PCLKSEL1 &=~(3<<16);
           LPC_SC->PCLKSEL1 |= (1<<16);
           //set DLAB = 1
           LPC_UART2->LCR |=(1<<7);
           //set frame size to 8
           LPC_UART2->LCR|=(3<<0);
           //set baud rate 57600
           uint8_t dll = sys_get_cpu_clock() / (16 * 38400); //get dll
           LPC_UART2->DLL = dll;

           //LPC_UART2->DLL =(0x625<<0)&0xFF;//or 104 if it changes
           //LPC_UART2->DLM =(0x625<<8)&0xFF;

           LPC_PINCON->PINSEL4 &= ~(0xF << 16); // Clear values
           LPC_PINCON->PINSEL4 |=  (0xA << 16);
           //Select tx2
           //LPC_PINCON->PINSEL0 |= (1 << 20);
           //Select rx2
           //LPC_PINCON->PINSEL0 |= (1 << 22);
           //SET dlab to 0
           LPC_UART2->LCR |=(0<<7);
           //Turn RX2 interrupts on
           LPC_UART2->IER |=(1<<0);

           LPC_UART2->IER |=(1<<2);//set rx line status to 1 bit 2

           LPC_UART2->FCR |=(1<<0);
           LPC_UART2->FCR |=(1<<1);
           LPC_UART2->FCR |=(1<<2);
           LPC_UART2->FCR |=(1<<3);
           LPC_UART2->FCR |=(0<<6);
           LPC_UART2->TER |=(1<<7); //transmit enable

           isr_register(UART2_IRQn, my_uart2_rx_intr);
           NVIC_EnableIRQ(UART2_IRQn);
    }
}*/
