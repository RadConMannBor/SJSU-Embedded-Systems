/*
 *     SocialLedge.com - Copyright (C) 2013
 *
 *     This file is part of free software framework for embedded processors.
 *     You can use it and/or distribute it as long as this copyright header
 *     remains unmodified.  The code is free for personal use and requires
 *     permission to use in a commercial product.
 *
 *      THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 *      OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 *      MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 *      I SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
 *      CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 *     You can reach the author of this software at :
 *          p r e e t . w i k i @ g m a i l . c o m
 */

#include "FreeRTOS.h"
#include "task.h"
#include "uart0_min.h"
#include "labGPIO0.h"
#include "stdlib.h"
#include "stdio.h"
bool switchedOn = false;
bool externalSwitchedOn = false;
bool eggSwitchedOn = false;




void vTaskOneCode(void * pvParameters)
{
    while(1)
    {
        uart0_puts("aaaaaaaaaaaaaaaaaaaa");
        vTaskDelay(100); // This sleeps the task for 100ms (because 1 RTOS tick = 1 millisecond)
    }
}

// Create another task and run this code in a while(1) loop
void vTaskTwoCode(void * pvParameters)
{
    while(1)
    {
        uart0_puts("bbbbbbbbbbbbbbbbbbbb");
        vTaskDelay(100);
    }
}



void vControlLED0( void * pvParameters )
{
    /* Get Parameter */
    uint32_t param = (uint32_t)(pvParameters);
    /* Define Constants Here */

    /* Define Local Variables and Objects */

    /* Initialization Code */
    LabGPIO_1 Port0Control(param);

    //printf("In Control LED0\n");
    while(1)
    {

        if(externalSwitchedOn)
               {
                   printf("Turn ON \n");
                   Port0Control.setDirection(true);
                   Port0Control.setLow();
                   vTaskDelay(100);
                   Port0Control.setHigh();
                   vTaskDelay(100);
                   Port0Control.setLow();
                   vTaskDelay(100);
                   Port0Control.setHigh();
               }
        vTaskDelay(100);
        /* Insert Loop Code */
    }
    /* Only necessary if above loop has a condition */
    //xTaskDelete(NULL);
}

void vReadSwitch0( void * pvParameters )
{
    /* Get Parameter */
    uint32_t param = (uint32_t)(pvParameters);
    /* Define Constants Here */

    /* Define Local Variables and Objects */

    /* Initialization Code */

    LabGPIO_0 Port0Read(param);
    Port0Read.setDirection(false);
    Port0Read.setAsInput();
           while(1)
              {
                  printf("Im in read \n");
                  if(Port0Read.getLevel())
                  {
                      externalSwitchedOn=true;
                      printf("Im in read Switch! true!   \n");


                  }
                  else{
                      printf("False \n");
                      externalSwitchedOn= false;
                  }

                  vTaskDelay(100);

                  /* Insert Loop Code */
              }
        /* Insert Loop Code */

    /* Only necessary if above loop has a condition */
    //xTaskDelete(NULL);
}


void vControlLED1( void * pvParameters )
{
    /* Get Parameter */
       uint32_t param = (uint32_t)(pvParameters);
       /* Define Constants Here */

       /* Define Local Variables and Objects */

       /* Initialization Code */
       LabGPIO_1 Port1Control(param);


       while(1)
           {
               printf("In Control LED1\n");
               if(switchedOn)
               {
                   printf("Turn ON \n");
                   Port1Control.setDirection(true);
                   Port1Control.setLow();
                   vTaskDelay(100);
                   Port1Control.setHigh();
                   vTaskDelay(100);
                   Port1Control.setLow();
                   vTaskDelay(100);
                   Port1Control.setHigh();
               }
               vTaskDelay(100);

               /* Insert Loop Code */
           }
       /* Only necessary if above loop has a condition */
       //xTaskDelete(NULL);
}

void vControlLEDegg( void * pvParameters )
{
    /* Get Parameter */
       uint32_t param = (uint32_t)(pvParameters);
       /* Define Constants Here */

       /* Define Local Variables and Objects */

       /* Initialization Code */
       LabGPIO_1 Port1Control(param);


       while(1)
           {
               printf("In Control LED1\n");
               if(eggSwitchedOn)
               {
                   printf("Turn ON \n");
                   Port1Control.setDirection(true);
                   Port1Control.setLow();
                   vTaskDelay(100);
                   Port1Control.setHigh();
                   vTaskDelay(100);
                   Port1Control.setLow();
                   vTaskDelay(100);
                   Port1Control.setHigh();
                   vTaskDelay(100);
                   Port1Control.setLow();
                   vTaskDelay(100);
                   Port1Control.setHigh();

                   vTaskDelay(200);
                   Port1Control.setLow();
                   vTaskDelay(300);
                   Port1Control.setHigh();
                    vTaskDelay(200);
                   Port1Control.setLow();
                   vTaskDelay(300);
                   Port1Control.setHigh();

                   Port1Control.setLow();
                  vTaskDelay(100);
                  Port1Control.setHigh();
                  vTaskDelay(100);
                  Port1Control.setLow();
                  vTaskDelay(100);
                  Port1Control.setHigh();
                  vTaskDelay(100);
                  Port1Control.setLow();
                  vTaskDelay(100);
                  Port1Control.setHigh();
                  vTaskDelay(100);
                Port1Control.setLow();
                vTaskDelay(100);
                Port1Control.setHigh();
               }
               vTaskDelay(100);

               /* Insert Loop Code */
           }
       /* Only necessary if above loop has a condition */
       //xTaskDelete(NULL);
}

void vReadSwitchegg( void * pvParameters )
{
    /* Get Parameter */
       uint32_t param = (uint32_t)(pvParameters);


       LabGPIO_1 Port1Read(param);
       while(1)
          {
             // printf("Im in read \n");
              if(Port1Read.getLevel())
              {
                  eggSwitchedOn=true;
                  printf("Im in read Switch! true!   \n");


              }
              else{
                  eggSwitchedOn= false;
              }

              vTaskDelay(100);

              /* Insert Loop Code */
          }
       /* Only necessary if above loop has a condition */
       //xTaskDelete(NULL);
}


void vReadSwitch1( void * pvParameters )
{
    /* Get Parameter */
       uint32_t param = (uint32_t)(pvParameters);


       LabGPIO_1 Port1Read(param);
       while(1)
          {
             // printf("Im in read \n");
              if(Port1Read.getLevel())
              {
                  switchedOn=true;
                  printf("Im in read Switch! true!   \n");


              }
              else{
                  switchedOn= false;
              }

              vTaskDelay(100);

              /* Insert Loop Code */
          }
       /* Only necessary if above loop has a condition */
       //xTaskDelete(NULL);
}



class LabGPIOInterrupts
{
private:
    /**
     * Your job here is to construct a lookup table matrix that correlates a pin
     * and port to a registered ISR. You may want to make additional probably need
     * more than one. Be clever here. How can you do this such that you and the
     * cpu do the least amount of work.
     */

public:
    /**
     * LabGPIOInterrupts should be a singleton, meaning, only one instance can exist at a time.
     * Look up how to implement this.
     */
    LabGPIOInterrupts();
    /**
     * 1) Should setup register "externalIRQHandler" as the EINT3 ISR.
     * 2) Should configure NVIC to notice EINT3 IRQs.
     */
    void init();
    /**
     * This handler should place a function pointer within the lookup table for the externalIRQHandler to find.
     *
     * @param[in] port         specify the GPIO port
     * @param[in] pin          specify the GPIO pin to assign an ISR to
     * @param[in] pin_isr      function to run when the interrupt event occurs
     * @param[in] condition    condition for the interrupt to occur on. RISING, FALLING or BOTH edges.
     * @return should return true if valid ports, pins, isrs were supplied and pin isr insertion was sucessful
     */
    bool attachInterruptHandler(uint8_t port, uint32_t pin, void (*pin_isr)(void), InterruptCondition_E condition);
    /**
     * After the init function has run, this will be executed whenever a proper
     * EINT3 external GPIO interrupt occurs. This function figure out which pin
     * has been interrupted and run the ccorrespondingISR for it using the lookup table.
     *
     * VERY IMPORTANT! Be sure to clear the interrupt flag that caused this
     * interrupt, or this function will be called again and again and again, ad infinitum.
     *
     * Also, NOTE that your code needs to be able to handle two GPIO interrupts occurring
     * at the same time.
     */
    static void externalIRQHandler(void);
    ~LabGPIOInterrupts();
};

// You can comment out the sample code of lpc1758_freertos project and run this code instead
int main(int argc, char const *argv[])
{
//    /// This "stack" memory is enough for each task to run properly
    const uint32_t STACK_SIZE = 1024;

    xTaskCreate(vReadSwitch0,
            "External One",          /* Text name for the task. */
            STACK_SIZE,      /* Stack size in words, not bytes. */
            ( void * ) 0,    /* Parameter passed into the task. */
            1,              /* Priority at which the task is created. */
            NULL );      /* Used to pass out the created task's handle. */
    xTaskCreate(vControlLED0,
            "External Two",          /* Text name for the task. */
            STACK_SIZE,      /* Stack size in words, not bytes. */
            ( void * ) 1,    /* Parameter passed into the task. */
            1,              /* Priority at which the task is created. */
            NULL );          /* Used to pass out the created task's handle. */
    xTaskCreate(vReadSwitch1,
               "Internal One",          /* Text name for the task. */
               STACK_SIZE,      /* Stack size in words, not bytes. */
               ( void * ) 9,    /* Parameter passed into the task. */
               1,              /* Priority at which the task is created. */
               NULL );      /* Used to pass out the created task's handle. */
   xTaskCreate(vControlLED1,
               "Internal Two",          /* Text name for the task. */
               STACK_SIZE,      /* Stack size in words, not bytes. */
               ( void * ) 0,    /* Parameter passed into the task. */
               1,              /* Priority at which the task is created. */
               NULL );          /* Used to pass out the created task's handle. */
   xTaskCreate(vReadSwitchegg,
              "Internal One",          /* Text name for the task. */
              STACK_SIZE,      /* Stack size in words, not bytes. */
              ( void * ) 10,    /* Parameter passed into the task. */
              1,              /* Priority at which the task is created. */
              NULL );      /* Used to pass out the created task's handle. */
  xTaskCreate(vControlLEDegg,
              "Internal Two",          /* Text name for the task. */
              STACK_SIZE,      /* Stack size in words, not bytes. */
              ( void * ) 8,    /* Parameter passed into the task. */
              1,              /* Priority at which the task is created. */
              NULL );
//    /* Start Scheduler - This will not return, and your tasks will start to run their while(1) loop */
    vTaskStartScheduler();




    return 0;
}




//--------------------------------------------------------------------

